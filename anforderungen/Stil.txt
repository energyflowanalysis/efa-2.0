# Bezeichner

* konsistent englische Bezeichner

* bei Wahrheitswerten: positiv formulierte Bezeichner
  Bei negativ formulierten Bezeichnern
  braucht man doppelte Verneinung für positiven Fall.

  Beispiel: `showIntro = True` statt `skipIntro = False`.

* camel case (jede Komponente eines Bezeichners beginnt mit Großbuchstaben)
  Wie geht man mit Abkürzungen um?

* `safe` oder `unsafe` sollte stehen für `pure` bzw. `impure`.
  Dagegen sollten nicht-totale Funktionen mit spezialisierter Fehlermeldung
  besser `checked` heißen.

  Beispiele:
>    unsafeNewIORef x = unsafePerformIO $ newIORef
>    checkedLookup x m = M.findWithDefault (error "x not in Map m") x m

* qualifizierte oder explizite Importe

  Beispiele:

>    import qualified EFA2.Signal.Signal as Signal
>    import EFA2.Signal.Signal (PSig)

  statt

>    import EFA2.Signal.Signal

* Bezeichner so wählen, dass sie mit Modulpräfix sinnvolle Bezeichnung ergeben

  Beispiel: Signal.plot, Signal.toList, Signal.fromList


# Syntax

* Reihenfolge der Importe: Spezialmodule vor allgemeinen Modulen
  Beispiel: erst `EFA2.Signal.Signal`, dann `Data.List`
  (siehe GHC-Richtlinien)
  So sieht man leichter, wenn man Module versehentlich mehrfach importiert.

* für jede Erweiterung eigenes LANGUAGE-Pragma
  (leichter zu editieren, besser für Diff, Git, ...)

  Besser so:
     {-# LANGUAGE MultiParamTypeClasses #-}
     {-# LANGUAGE TypeFamilies #-}
     {-# LANGUAGE FlexibleInstances #-}
  als so:
     {-# LANGUAGE MultiParamTypeClasses, TypeFamilies, FlexibleInstances #-}

* mehrzeilige Kommentare mit {- -}
  nicht jede Zeile mit -- beginnen (schwieriger zu editieren)

* keine Leerzeichen am Ende von Zeilen

* keine Tabulatoren (es gibt auch eine Warnung dafür)
  sonst kommt GHC bei Konstrukten durcheinander,
  wo es auf die Einrückung ankommt.


# Typen

* Typsignaturen für alle globalen Bezeichner

  Hinweis: Typannotation ersetzt keine Typsignatur
  Deswegen immer so:
>     n :: Int
>     n = 5
  statt so
>     n = 5 :: Int

* Type-Synonyme maximal eta-reduzieren, d.h.

>    type MyList = []

  statt

>    type MyList a = [a]

  Auf diese Weise kann man auch mal `MyList` als Typparameter verwenden,
  wo ein Typkonstruktor gebraucht wird.


# Typklassen

* möglichst keine verwaisten Typklassenausprägungen (orphan instances)
  Gefahr von Konflikten zwischen Ausprägungen

* möglichst alle Methoden einer Typklasse implementieren,
  sonst Typklassen verkleinern
  Beispiel: DrawTopology vs. DrawDeltaTopology

* bestimmte Erweiterungen vermeiden:
    OverlappingInstances
    UndecidableInstances lassen sich manchmal mit Typfamilien vermeiden
    TypeSynonymInstances lassen sich durch zusätzliche Klasse vermeiden
    FlexibleInstances lassen sich durch zusätzliche Klasse vermeiden

* Klasse mit nur einer 'instance' sollte es eigentlich nicht geben.
  Überhaupt sollte es keine 'catch-all instance' geben,
  also eine Klassenausprägung, bei der nur Typvariablen als Parameter vorkommen.

  Beispiel:
     SZipWith s1 s2 s3 c1 c2 d1 d2 d3

  Dann besser gar keine Klasse und stattdessen eine polymorphe Funktion.
  Oder sollte man Klassensynonyme nehmen? (relativ neue Typerweiterung)



# andere Programmiertipps

* GHC-Warnungen einschalten und beachten (Option -Wall)
   (noch mehr Warnungsoptionen ...)

* Show instance sollte Haskell-Code ausgeben, nichts formatiertes

* `mapM_ f xs` ist effizienter als `void $ mapM f xs`
  beachte Warnung vor ignorierten monadischen Ergebnissen

* Rekursion richtig aufziehen
     falsch: wiederholt an Akkumulator mit (++) ein einzelnes Element hintendran hängen
                (quadratische Laufzeit, nicht lazy)
     falsch: wiederholt an Akkumulator vorne mit (:) anhängen und zum Schluss mit reverse umdrehen
                (lineare Laufzeit, aber immer noch nicht lazy)
     richtig: ohne Akkumulator vor Rest der Rekursion hängen

* besser Maybe, Either & Co. als Spezialwerte,
  wie bei ">=0 bedeutet Anzahl geschriebene Bytes, <0 Errorcode"
  Spezialwerte zu fehleranfällig
  schlechtes Beispiel: noRecord

* möglichst kein error, head, fromJust, irrefutable matching,
  stattdessen Typen, die genau das erlauben, was gebraucht wird


# Versionverwaltung

* Jede Änderung an `master` sollte lauffähig sein.
  D.h. `cabal install` (und später `cabal test`) soll fehlerfrei durchlaufen

* Git-Kommentar mit betroffenem Modul beginnen
  Beispiel:

>   Modul: Änderung

* Binärdateien vermeiden, große erst recht
  temporäre oder erzeugte Dateien sollten nicht in Versionsverwaltung,
  stattdessen in .gitignore aufnehmen.

* In Programmkommentaren und LaTeX-Dokumenten:
  Texte immer in Sinneinheiten umbrechen,
  keine Blockformatierung, nicht den ganzen Absatz auf eine Zeile.
  So funktioniert Diff besser.

  So:
    Es war einmal ein kleines süßes Mädchen,
    das hatte jedermann lieb, der es nur ansah,
    am allerliebsten aber seine Großmutter,
    die wusste gar nicht, was sie alles dem Kinde geben sollte.
    Einmal schenkte sie ihm ein Käppchen von rotem Samt,
    und weil ihm das so wohl stand, und es nichts anders mehr tragen wollte,
    hieß es nur das Rotkäppchen.

  statt so:
    Es war einmal ein kleines süßes Mädchen, das hatte jedermann lieb, der es nur
    ansah, am allerliebsten aber seine Großmutter, die wusste gar nicht, was sie
    alles dem Kinde geben sollte. Einmal schenkte sie ihm ein Käppchen von rotem
    Samt, und weil ihm das so wohl stand, und es nichts anders mehr tragen wollte,
    hieß es nur das Rotkäppchen.

  oder so:
    Es war einmal ein kleines süßes Mädchen, das hatte jedermann lieb, der es nur ansah, am allerliebsten aber seine Großmutter, die wusste gar nicht, was sie alles dem Kinde geben sollte. Einmal schenkte sie ihm ein Käppchen von rotem Samt, und weil ihm das so wohl stand, und es nichts anders mehr tragen wollte, hieß es nur das Rotkäppchen.
