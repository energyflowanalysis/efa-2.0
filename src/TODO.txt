
TODO-List (Aufzählung ohne Prioritäten):

1. Die Display-Funktionalität muss überdacht und überarbeitet werden. In EFA2/Display/DrawGraph.hs herrscht ein Wildwuchs an Funktionen. Das Display soll die verschiedenen Datentypen in EFA2/Signal/Signal.hs berücksichtigen können.


2. Der Datentyp (:>) in EFA2/Signal/Data.hs hat vier Konstruktoren D0, D1, D2, D3. Bei den Instanzen haben wir für jeden Konstruktor eine Instanz. Beispielsweise gibt es vier Show-Instanzen für Nil v0, (v1 :> v0) Nil, etc., die jede nur gegen einen der D0, D1, etc. Konstruktoren matcht. Bessere Idee? Typfamilien vielleicht?

3. Der Interpreter kann Gleichungen der Form n = Pout * (1 / Pin) im Moment nicht interpretieren. Auskommentierter Code ist vorhanden in interpretEq (EFA2/Interpreter/Interpreter.hs) Das Problem ist, dass n (Wirkungsgrad eta) in Wirklichkeit eine Funktion der Eingangsleistung ist, die Grundgleichung also lautet: Pin * n(Pin) = P(out). Die Leistungen Pin und Pout codieren Stützstellen folgender Form: (Pin[x], Pout[x]/Pin[x]). Daraus soll sich n als interpolierte Funktion ergeben.

4. Offenes Problem: Den Rückwärtswirkungsgrades von n(Pin) = Pout * (1 / Pin) berechnen: Die Funktion n :: Double -> Double und Pout sind gegeben, Pin ist gesucht, so dass obige Gleichung gilt. Wahrscheinlich ist die Lösung für beliebige Funktionen n nicht eindeutig. Anforderungen an n formulieren. Eine Funktion n' :: Double -> Double berechnen, so dass n'(Pout) * Pout = Pin. Iterationsverfahren entwerfen? ACHTUNG: Der Code berechnet zur Zeit n(Pout)*Pout = Pin oder irgend so etwas. Jedenfalls ist dort ein BUGGG!!!!

5. StateAnalyisis.hs: Schnellermachen durch vorsortieren der einzfügenden Kanten. Idee: Wenn man alle Knoten nacheinander mit Kanten saturiert, können ungültige Zustände schneller erkannt werden, als wenn man die Kanten in beliebiger Reihenfolge einfügt. Paralellisierung möglich/nötig?

Die algebraischen Eigenschaften der Mengen der Zuständen kann man sich vielleicht zu eigen machen, um eine Algebra der Zustände zu entwerfen. Wir brauchen auch ein Abstandsmass, dass einen Abstand zwischen zwei Zuständen ermittelt. Warum? Falls ungültige Zustände aus realen Messungen auftreten, muss evtl. daraus ein gültiger Zustand hergestellt werden => Entscheidungsprozedur.

6. Computer Algebra: Da additive Terme das wichtigste sind, sollen alle Terme der Form x + y + z + ... sein, wobei x, y, z usw. ihrerseits multiplikative Terme sind, d.h. alles soll voll ausmultipliziert sein. Die multiplikativen Terme sollen wiederum zusammengefasst werden, z.b. zu Potenzen, und auch gekürzt sollten sie vollständig sein, 1-Faktoren sollten nicht auftreten. Die Faktoren sollten in einer Standardreihenfolge erscheinen oder die Reihenfolge sollte konfigurierbar sein. D.h. eine kanonische Darstellung soll entwickelt werden. Ansätze finden sich in simplify (EFA2/Solver/Equation.hs).

Auch transformEq (EFA2/Solver/Equation.hs) sollte davon profitieren können. Limitierend ist hier, dass nach einer Variable nur aufgelöst werden kann, wenn sie nur einmal in einer Gleichung vorkommt. Es gibt aber Gleichungen, wo variablen zusammengefasst werden können und eine Auflösung dann möglich ist.


7. fromJust, head, tail, etc. ersetzen durch pattern-Matching.

1000. Testen mit SmallCheck und QuickCheck. Aufbau einer TestSuite.

- Die Graphenimplementierung EfaGraph in EFA2/Topology/EfaGraph.hs
- StateAnalysis.hs: Die Mengen der Zustände haben algebraische Eigenschaften, die man prüfen kann: Vereinigung, Schnitt, Mächtigkeit usw.
- Computer Algebra soll getestet werden.
